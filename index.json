
[{"content":" Purpose # This is to configure an Android device with a custom kernel to run a full LXC environment on external storage. Unlike the chroot or proot configurations, this allows use of Docker to run containers, alongside systemd to manage services. Therefore, this allows an Android device to run as close to a \u0026ldquo;full\u0026rdquo; Linux environment as possible (without virtualisation).\nSkills Demonstrated # Linux / Bash Command Line Administration SSH Hardening Android Kernel Configuration Container Networking Configuration Troubleshooting, Decision-Making With Limited Information Available IMPORTANT NOTE BEFORE WE BEGIN! # In order for Docker to work inside the LXC, I configured a custom kernel that mounts the cpuset groups of mems and cpus with the cpuset prefix (cpuset.mems and cupset.cpus respectively), as standard Linux installations are meant to.\nThe default Termux LXC package has been customised to look for mems and cpus WITHOUT the cpuset prefix (and therefore will not run if they are mounted WITH the prefix), but the standard Docker installation (which is installed inside the LXC) looks for mems and cpus WITH the prefix, and will not run if they are mounted WITHOUT the prefix. Therefore, I made a custom version of the Termux LXC package, changing the source code to remove that customisation, and then rebuilding the package accordingly.\nThe system does note that systemd is designed for kernels 4.15 or above, but the device I tested on, the Exynos variant of the Samsung s10e, is currently on kernel version 4.14, so it warns to expect unpredictable behaviour. As of writing, it works fine for my purposes.\nPrerequisites # A custom Kernel installed with all flags for Docker enabled (tested on Samsung s10e (Exynos) with customised CruelKernel installed over the latest supported stock OS, which in this case is Android 12), AND the noprefix option REMOVED from mounting the mems and cpus cgroups. A rooted device (tested with Magisk v27.0) Termux installed and granted root access root-repo and tsu installed inside Termux (to allow the use of the sudo command) A custom lxc package installed, configured to search for the cpuset.mems and cpuset.cpus cgroups - you can either use my provided build , or make the changes and build it yourself on your own machine. An external micro SD card formatted as ext4 LXC on Internal Storage (do NOT need to perform this step if using SD card) # These steps are also applicable using the device\u0026rsquo;s internal storage if there is no SD card available, but file-based encryption on the device can pose a challenge to the proper functioning of the LXC environment. In my experience, using a folder within /data as the lxc storage works (for example, creating the folder /data/lxc), but /data needs to first be remounted with the nosuid option in the Termux shell:\nsudo mount -o remount,suid /data Step 1: Mounting Cgroups as v1 # Save this script to an easily-accessible location (in my case, I saved it to the Termux home directory) and then run it as root. This mounts cgroups, which is what allows the isolation of processes in LXC.\n(Source of script) Important: it\u0026rsquo;s important to confirm that /proc/self/mountinfo does NOT mention \u0026ldquo;cgroup2\u0026rdquo;. From my understanding, \u0026ldquo;cgroup2\u0026rdquo; being present means that the cgroups are mounted as v2, but the current Termux LXC is configured to only use v1 cgroups. Cgroups being mounted as v2 confuses the program and renders it unable to start.\nStep 2: Editing LXC Configuration Files # By default, these should be at:\n/data/data/com.termux/files/usr/share/lxc/config/common.conf /data/data/com.termux/files/usr/etc/lxc/default.conf common.conf # Comment out the entire part that shows lxc.devices.allow/deny, then add above it:\nlxc.cgroup.devices.allow= lxc.cgroup.devices.deny= The default lxc config restricts the devices used by LXC, but on Android with its different device style to standard Linux machines, it unfortunately prevents LXC from booting entirely. These configurations set both allow and deny lists to clear, making it so that LXC can boot on its own.\nAdd to the bottom:\nlxc.init.cmd = /sbin/init systemd.unified_cgroup_hierarchy=0 This configuration reminds the container that it needs to use the v1 version of cgroups.\nAn example common.conf file is located here. default.conf # By default, this file\u0026rsquo;s contents are:\nlxc.net.0.type = empty empty should be changed to to none:\nlxc.net.0.type = none empty means that by default, the Linux environments created won\u0026rsquo;t have network access. Changing the setting to none gives the Linux environments access to the network configuration of the host Android device. However, note that additional configuration still needs to be carried out on each Linux environment that is created, for the Android system to allow them network access. Step 3: Creating LXC # The LXC must be created in an unencrypted location.\nExample with Debian Bookworm LXC being installed to an sd card mounted at /data/local/debian and installing to /data/local/debian/lxc:\n# Creating folder to store the LXC root sudo mkdir /data/local/debian/lxc # Installing the LXC environment to that folder sudo lxc-create --dir=/data/local/debian/lxc -t download -n debian -- --no-validate -d debian -r bookworm -a arm64 If you are using internal storage, you need to create your folder (or folders) directly inside /data, NOT inside /data/local, because /data/local is an encrypted location. In my case, because uninstalling an LXC environment deletes its entire folder, I\u0026rsquo;ve decided to create a parent folder for the LXC as a \u0026ldquo;marker\u0026rdquo;, or reminder of where to make more. It isn\u0026rsquo;t necessary to follow this exactly - to my knowledge, you could directly create a folder called /data/debian and install the LXC there if you like.\n# Creating a folder AND a subfolder: # /data/lxc is like a \u0026#39;buffer\u0026#39; - \u0026#39;marking\u0026#39; a dedicated place to create LXC environments, # that won\u0026#39;t be deleted if this Debian LXC is uninstalled in the future # /data/lxc/debian is going to be where the LXC environment will actually be installed sudo mkdir -p /data/lxc/debian # Installing the LXC environment sudo lxc-create --dir=/data/lxc/debian -t download -n debian -- --no-validate -d debian -r bookworm -a arm64 --no-validate must be included in the command because Termux LXC package cannot use a keychain.\nIMPORTANT!!\nThe directory you install to needs to exist FIRST. If you are using externally mounted storage, the LXC directory should NOT be the root of the mounted storage. For example, if it is mounted at /data/local/debian, the LXC should be installed to a SUBFOLDER. This is because if you need to uninstall the lxc later, deleting it through lxc-destroy will try to delete the directory of the mounted device itself and fail. Step 4: Enabling Password Login # By default, the LXC will not allow you to login, and due to a quirk of Android, the lxc-attach command that is usually used to get around it will not work. Therefore, you need to edit the password file of the LXC in Termux, before you actually boot the LXC.\nIn the case of the example where the LXC is installed to /data/local/debian/lxc:\nsudo vim /data/local/debian/lxc/etc/shadow By default, the line of the root user will look like below, with the * meaning that password login is not possible:\nroot:*:20215:0:99999:7::: Replace the * with paa5KD6arxLr2\nroot:paa5KD6arxLr2:20215:0:99999:7::: This will change the password to 123456.\nSource: machine-translated version of https://www.cnblogs.com/ifwz/p/17592111.html It will then be possible to login through providing the username root and the password 123456:\nsudo lxc-start -F debian For security purposes, you MUST change the root user password immediately afterwards to a more secure password of your choosing through the passwd command.\nStep 5: Enabling Networking, Creating Standard User # Source for networking changes As with Chroot Linux installations on Android, the Android host by default will not allow any network access unless the user is part of the group with the ID 3003. Both the root and _apt user need these permissions added to them - root to allow network access when executing root commands, and _apt to allow package management.\n# creating a group called \u0026#34;aid_inet\u0026#34; with group ID 3003 groupadd -g 3003 aid_inet # changing the _apt user\u0026#39;s primary group to 3003 # has to be the PRIMARY group, otherwise the default \u0026#34;nogroup\u0026#34; will override usermod -g 3003 _apt # Need to add to the root user as well usermod -aG 3003 root # log out and in for group to apply exit As per Linux best practices of ONLY using root when absolutely necessary (and using sudo for regular situations), a regular user should now be created.\nIn this example, creating a user called user, having the aid_inet group as the user\u0026rsquo;s primary group so they have network access by default:\n# Creating a user called \u0026#34;user\u0026#34;, creating their home dir useradd user -s /bin/bash -m # Changing \u0026#34;user\u0026#34;\u0026#39;s primary group to 3003 usermod -g 3003 user # Switching to \u0026#34;user\u0026#34; su user # Testing ping - should be successful ping 1.1.1.1 The user must also be added to the sudoers file via visudo, to allow them to use sudo and perform administrative commands.\nIn my case, because I intend to exclusively use SSH key authentication (which I will cover in my next step), I\u0026rsquo;m adding in NOPASSWD to both root and user, meaning that the user will not need to enter in a password for sudo use.\nI have changed the lines under #User privilege specification from:\n# User privilege specification root ALL=(ALL:ALL) ALL to:\n# User privilege specification root ALL=(ALL:ALL) NOPASSWD: ALL user ALL=(ALL:ALL) NOPASSWD: ALL Another aspect similar to chroot installations, is the system needing a DNS address assigned manually. This can be done through editing /etc/systemd/resolved.conf through a terminal text editor (such as vim or nano) with sudo permissions.\nThe line DNS= should be uncommented, and then filled in with a DNS address of your choice. 1.1.1.1 (CloudFlare) or 9.9.9.9 (Quad9) tend to be solid options.\nHere is an example of the resolved.conf file after adding DNS 1.1.1.1. Restart the DNS service, then test the ping command using a hostname. The ping should be successful.\nsudo systemctl restart systemd-resolved ping www.google.com Step 6: Enabling SSH Access # Inside LXC, install openssh-server. This should automatically configure the SSH service to start when the LXC boots. Therefore, running sudo lxc-start debian would allow access from SSH directly rather than needing to run sudo lxc-start -F debian from Termux shell. Because LXC broadcasts on usual SSH port rather than port 8022 like Termux does, it\u0026rsquo;s possible to access both the LXC and the actual Android Termux shell via SSH through the same IP address.\nNOTE: I HIGHLY recommend first setting up SSH public key access, disabling password access, through changing the line PasswordAuthentication yes to PasswordAuthentication no in /etc/ssh/sshd_config and then running sudo systemctl restart ssh.service.\nIn order to auto-start the LXC and SSH access to it on boot, there are two scripts I have made, depending on whether you use internal or external storage.\nBoth presume that the name of the LXC is debian, so please edit the examples accordingly if you have configured your setup differently.\nExternal Storage Autostart # Save this script to ~/.termux/boot and have it executable. On boot, this will auto-mount the external storage, mount the required cgroups, and then start the LXC.\nIn addition to the name of the LXC, this also presumes:\nthe SD card block device is /dev/block/mmcblk0 the SD card is mounted to /data/local/debian Internal Storage # Save this script to ~/.termux/boot and have it executable.\nOn boot, this will remount the /data folder with the suid option (allowing use of sudo for standard users), mount the required cgroups, and then start the LXC.\nStep 7: Installing and Configuring Docker # Due to Android\u0026rsquo;s networking restrictions, additional configuration needs to be carried out with how Docker is utilised. Specifically:\nthe Docker daemon needs to be manually started, Android does not support iptables, all containers must be run on the host network. # Installing Tmux to allow background terminal sessions (dockerd needs to be started manually, then run in the background) sudo apt install tmux # Installing docker and docker-compose (so can run compose template files) sudo apt install docker.io docker-compose Create file /etc/docker/daemon.json, and set the option iptables to false - this is another quirk of Android, where Docker doesn\u0026rsquo;t work on Android if the iptables option is set to true.\nContents of /etc/docker/daemon.json:\n{ \u0026#34;iptables\u0026#34;: false } Create new tmux session by running tmux, then run sudo dockerd. Once dockerd has started, detach from the session by pressing Ctrl+B D.\nRun sudo docker run hello-world , the program should properly run.\nNote: These following examples with Jellyfin and Calibre-Web-Automated are just examples to test that the services work, not services that can permanently run. They do not have any permanent storage passed through. For actual permanent containers, I recommend utilising docker-compose.yml files.\nAs stated above, you need to run containers with host network mode, i.e.,\nsudo docker run --network=host jellyfin/jellyfin Otherwise, you will NOT be able to access the services on the network!! Also, once more, due to Android\u0026rsquo;s networking restrictions, if a container does not run with the current user\u0026rsquo;s PGID (Process Group ID) by default, such as calibre-web-automated, you must change the GID to 3003, otherwise the container will not have permission to even start a server.\ndocker run -e PGID=3003 --network=host crocodilestick/calibre-web-automated:latest As per usual Docker practices, add your user to the docker group if you would like to run the docker client without needing sudo:\nsudo usermod -aG docker user Then log out and in for it to take effect.\nPlease note that you do still need to run dockerd as sudo.\nDockerd Autostart # I have found that dockerd autostarting or not can be inconsistent. Sometimes it starts up on its own, sometimes it does not start up on its own (the reason for the latter being that the systemd service somehow does not detect the iptables=false flag. Therefore, if you find that dockerd does not run on restarting your device or the LXC container, run sudo dockerd in a tmux session and then detach from it with Ctrl+B D.\nStep 8 (OPTIONAL): General Linux QOL Features # These are not necessary for LXC to function, but they are nice to have. Install command-not-found so have better information if a command doesn\u0026rsquo;t work\nsudo apt install command-not-found sudo apt-file update Need to log out and in to take effect.\nInstall apt-utils so that packages can be installed more efficiently (configuration can occur BEFORE installation rather than after) (Source) sudo apt install apt-utils Note regarding shutdown and reboot commands # Unlike a chroot environment, where power-related commands simply fail, running sudo shutdown now or sudo reboot now inside the LXC will work. However, they don\u0026rsquo;t actually power off or reboot the host device, it\u0026rsquo;s more akin to restarting a Virtual Machine.\n","date":"8 May 2025","externalUrl":null,"permalink":"/posts/2025-05-08-lxc/","section":"Posts","summary":"Purpose # This is to configure an Android device with a custom kernel to run a full LXC environment on external storage.","title":"Debian LXC and Docker in Termux","type":"posts"},{"content":"","date":"8 May 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"8 May 2025","externalUrl":null,"permalink":"/","section":"Simple Selfhosted Server Guides","summary":"","title":"Simple Selfhosted Server Guides","type":"page"},{"content":" Summary # This is a guide to set up userspace Wireguard on the Kobo Clara Colour eReader, allowing you to connect the Kobo to a VPN that uses Wireguard configuration files. The use-case for this, is using a VPN that to connects to a personal network, allowing the user to access eBook servers hosted on their personal devices.\nSkills Demonstrated # Working with embedded Linux terminals Cross-compiling Networking/VPN configuration SSH hardening IMPORTANT INFORMATION # Persistence Across Firmware Updates # With my current experience involving Kobo firmware updates: after an update, the installed files and configurations remain, but in order to access the terminal that can start the VPN again, you need connect the Kobo to a computer through USB and run the script to install KFMon. This can be retrieved from the same page as the KOReader install package below .\nVPN Has To Be Activated On Each Reboot # It is technically possible to automatically run a script that starts the VPN on each device reboot.\nHowever, there is the risk of losing network access while configuring the scripts, or if the Wireguard server were to malfunction while tunnelling all traffic through it.\nThe only way to restore network access in that situation would be through the on-device terminal, which is awkward to use for extended periods, and as stated above, is temporarily lost on firmware updates.\nI feel that it would be best to keep the device in a state where if a networking mishap occurred, you could restore normal functionality with a simple device reboot.\nInstalling KOReader # Install KOReader through NiLuJe\u0026rsquo;s One-Click Install package , following the instructions for your respective Operating System. In addition to providing an excellent reading environment, KOReader functions as a terminal through which you can access your device\u0026rsquo;s root filesystem and run Linux commands. The terminal functionality is a key part of enabling the VPN connection.\nHow to Access Terminal in KOReader Tap the top bar to open the KOReader menu.\nSelect the Settings icon.\nGo to Page 2 of the Settings section.\nSelect the More Tools button.\nSelect the Terminal Emulator button.\nSelect the Open terminal session (not running) option.\nSetting up SSH access # KOReader\u0026rsquo;s SSH package is unfortunately outdated and insecure, which causes it to have connectivity issues with modern computers. Luckily, NiLuJe\u0026rsquo;s Yet another telnet/sshd \u0026amp; misc tools package provided on the MobileRead forums has a properly functioning SSH service through the program Dropbear.\nFollow the instructions as described in the forum to install the package.\nPLEASE DO NOT DO THIS STEP ON PUBLIC WIFI. By default, SSH access allows anyone to connect without the need for a password or key. Securing SSH access to use public key auth only:\nIf you don\u0026rsquo;t have an SSH key registered on your main device yet, generate one. This is done with the command:\nssh-keygen Next, open the public key file, which as of OpenSSH 9.x\u0026rsquo;s defaults, should be id_ed25519.pub in a text editor, and copy its contents to the clipboard.\nSSH to your Kobo device. The IP address of the device can be found in the KOReader menu through the Settings/Gear Icon -\u0026gt; Network -\u0026gt; Network Info. The user is root, meaning that if the Kobo\u0026rsquo;s IP address was 192.168.1.128, the command to connect would be:\nssh root@192.168.1.128 Make sure that the Kobo does NOT fall asleep while connected.\nOnce connected to the Kobo through SSH, execute the command to create and edit the file containing the Kobo\u0026rsquo;s authorised public keys.\nvi /usr/local/niluje/usbnet/etc/authorized_keys Press i to enter Insert Mode, then press Ctrl+Shift+v to paste the public key into the file. Press :wq to save the file and quit.\nExecute the command to edit the options for the Kobo\u0026rsquo;s SSH service:\nvi /usr/local/stuff/bin/stuff-daemons.sh Uncomment Line 22. The line should be, #SSHD_OPTS=\u0026quot;${SSHD_OPTS} -s\u0026quot;, and the line above should have the comment, NOTE: Uncomment if you want to limit dropbear to shared-key auth only. You need to remove the #.\nLine 22 Before:\n## NOTE: Uncomment if you want to limit dropbear to shared-key auth only #SSHD_OPTS=\u0026#34;${SSHD_OPTS} -s\u0026#34; Line 22 After:\n## NOTE: Uncomment if you want to limit dropbear to shared-key auth only SSHD_OPTS=\u0026#34;${SSHD_OPTS} -s\u0026#34; Compiling/Retrieving Wireguard Binaries # Userspace Wireguard # I have decided to use the userspace program wireguard-go, alongside wireguard-tools to manage the interfaces, rather than Wireguard\u0026rsquo;s kernel modules.\nThe Kobo does support Wireguard\u0026rsquo;s kernel modules, as demonstrated by the terminal when running wireguard-go:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ Running wireguard-go is not required because this ‚îÇ ‚îÇ kernel has first class support for WireGuard. For ‚îÇ ‚îÇ information on installing the kernel module, ‚îÇ ‚îÇ please visit: ‚îÇ ‚îÇ https://www.wireguard.com/install/ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò However, as the documentation on the Kobo kernel states, if the kernel were to malfunction, then it would require physically opening up the device and physically accessing the storage to fix.\nSecondly, with newer devices such as the Kobo Clara Colour, the model has eMMC storage rather than an internal SD card, meaning that if the device were rendered unbootable, specialised equipment would be required to access the storage.\nLastly, wireguard-go is the same version of Wireguard that the proprietary service Tailscale uses. A version of Tailscale for the Kobo exists and is proven to work.\nObtaining the wireguard-go binary # wireguard-go is already available in the form of various pre-compiled binaries from this repository . The Kobo has a 32-bit ARM processor, so the version to download, as of writing, is wireguard-go-linux-arm.tar.gz .\nCross-compiling wireguard-tools # The Kobo Clara uses a 32-bit ARM processor, meaning that the wg binary from wireguard-tools needs to be specifically cross-compiled for it. I have already cross-compiled the binary for my Kobo, which is downloadable here .\nIf you would like to compile it yourself, then you will need to be running Linux. Download koxtoolchain scripts: both the scripts from the repository itself, and the prebuilt kobov4 toolchain.\nDownload the kobov4 toolchain to your home directory As of writing, the Kobo Clara runs firmware of version 4.x. Download the koxtoolchain repository itself as an archive to your home directory Download the wireguard-tools repository to your home directory Extract all three downloaded archives. Your home directory should have three new folders: koxtoolchain-2025.01 x-tools wireguard-tools Add x-tools/arm-kobov4-linux-gnueabihf/bin to your PATH. This can be done by adding this line to the bottom of the .bashrc file in the home directory: PATH=$PATH:/full/path/to/x-tools/arm-kobov4-linux-gnueabihf/bin/ If the Terminal is open, close it and reopen it for the change to take effect. Install the build-essential package, which provides dependencies for compiling: sudo apt install build-essential Open a Terminal in the home directory, then run the command to activate the compiling environment: source koxtoolchain-2025.01/refs/x-compile.sh kobov4 env bare Run this command to cross-compile the binary: make CC=$HOME/x-tools/arm-kobov4-linux-gnueabihf/bin/arm-kobov4-linux-gnueabihf-gcc-14.2.0 -C wireguard-tools/src The resultant binary will be located in the wireguard-tools/src folder, with the name wg. This is the file that needs to be copied to your Kobo. Transferring Binaries to the Kobo # So as not to interfere with the Kobo\u0026rsquo;s default system files (which are likely to be overridden upon a system update), the wg binary and the wireguard-go binary are to be placed in the directory /usr/local/bin.\nEditing Wireguard Conf File # For this step, an example Wireguard configuration file from PiVPN was used, and I only used IPv4 addresses.\nThe tool wg-quick, which is used in most \u0026ldquo;full\u0026rdquo; systems to create Wireguard connections, does not work here because the programs it depends on such as setopt, systemd, and resolvconf do not exist on the Kobo OS.\nTherefore, you need to manually change the Wireguard configuration file to allow the wg binary to process it:\nRecord the two lines in the [Interface] section beginning with Address = and DNS = in another document, then remove them from the configuration file.\nAdd this line at the bottom of the document: PersistentKeepAlive = 60 . Without this line, the IP address of the Kobo will needed to be pinged from the outside in order for the network connection to start.\nDepending on your personal preferences, the line AllowedIPs = 0.0.0.0/0, ::0/0 to the range of IP addresses you would like to use the VPN for, as well as the IP address range of the VPN\u0026rsquo;s internal network.\nFor example, if you only want to use the VPN for IP addresses in the 192.168.1.x range, and the IP address range of the VPN\u0026rsquo;s internal network is 10.10.0.x you would replace the line with: AllowedIPs = 192.168.1.0/24, 10.10.0.0/24\nGenerated Wireguard conf file example:\n[Interface] PrivateKey = PRIVATE_KEY Address = KOBO_IPV4_ADDRESS, KOBO_IPV6_ADDRESS DNS = WIREGUARD_DNS_ADDRESS [Peer] PublicKey = PUBLIC_KEY PresharedKey = PRESHARED_KEY Endpoint = ENDPOINT_IPV4_ADDRESS AllowedIPs = 0.0.0.0/0, ::0/0 The same file, edited for the Kobo:\n[Interface] PrivateKey = PRIVATE_KEY [Peer] PublicKey = PUBLIC_KEY PresharedKey = PRESHARED_KEY Endpoint = ENDPOINT_IPV4_ADDRESS AllowedIPs = 192.168.1.0/24, 10.10.0.0/24 PersistentKeepAlive = 60 Remember:\nThis presumes you would like to split-tunnel network access, using the examples of 192.168.1.0/24 for the devices on the destination network and 10.10.0.0/24 for the Wireguard network itself. The KOBO_IPV4_ADDRESS and WIREGUARD_DNS_ADDRESS values must be recorded in a separate document Transfer the final conf file to an easy-to-access place on the Kobo device. In my case, I have saved the script inside /mnt/onboard, which is the same place where user files such as books are saved.\nThis location was chosen because it won\u0026rsquo;t be overridden upon firmware updates, and it is easily accessible over USB. I recommend the filename being a simple name, without spaces, as it will be required for the launching script.\nFinal Steps on Kobo # Configuring KOReader to properly load the PATH # First of all, KOReader\u0026rsquo;s Terminal needs to be configured to acknowledge that the directory /usr/local/bin contains executable files. This can be done by SSHing into the Kobo, creating the file /mnt/onboard/.adds/koreader/scripts/profile.user, and then entering in contents as:\nPATH=$PATH:/usr/local/bin Now whenever the KOReader terminal (NOT the SSH terminal) is started, it can run programs and scripts stored inside /usr/local/bin.\nConfiguring VPN DNS # Because wg-quick cannot be used and DNS isn\u0026rsquo;t set by PiVPN automatically, you need to add the DNS servers in /etc/resolv.conf in order to ensure proper internet connectivity. This is where you paste in the addresses of the DNS servers from the original Wireguard configuration file.\nFor example, if you wanted to use the 1.1.1.1 DNS server and its fallback 1.0.0.1, you would enter inside the file, two lines:\nnameserver 1.1.1.1 nameserver 1.0.0.1 The /etc/resolv.conf file would look like this at the end:\n# Generated by dhcpcd from wlan0 # /etc/resolv.conf.head can replace this line domain local nameserver 1.1.1.1 nameserver 1.0.0.1 # /etc/resolv.conf.tail can replace this line Creating VPN-launching Script # Finally, you write the script that you will run to launch the VPN from the KOReader terminal.\nA template for split-tunnelling is as follows:\n#!/bin/sh wireguard-go wg0 wg setconf wg0 $PATH_TO_WIREGUARD_CONFIG ip link set wg0 up ip addr add $WIREGUARD_KOBO_IP dev wg0 ip route add $WIREGUARD_NETWORK_ADDRESS dev wg0 ip route add $DESTINATION_NETWORK_ADDRESS dev wg0 What this does is:\nCreate a Wireguard interface Configure the Wireguard interface according to the provided conf file Activate the Wireguard interface Give the Wireguard interface the IP address that the Kobo has been assigned in the Wireguard network This is where you would paste the IPv4 address that you copied while editing the conf file. Tell the Kobo to use the Wireguard network interface when contacting IP addresses in the Wireguard network Tell the Kobo to use the Wireguard network interface when contacting IP addresses in the local destination network Using the variables:\n/mnt/onboard/wireguard-kobo.conf is the location of the configuration file The Kobo\u0026rsquo;s IP address in the Wireguard network is 10.10.0.2 The Wireguard network address is 10.10.0.0/24 The destination network, which has local devices that you would like the Kobo to access, has the address 192.168.1.0/24 #!/bin/sh wireguard-go wg0 wg setconf wg0 /mnt/onboard/wireguard-kobo.conf ip link set wg0 up ip addr add 10.10.0.2/24 dev wg0 ip route add 10.10.0.0/24 dev wg0 ip route add 192.168.1.0/24 dev wg0 Save the script as /usr/local/bin/vpn and use chmod +x to make it executable. Now to activate the Wireguard VPN, you need to go to KOReader Terminal and type vpn, then press enter. This will remain active until the device powers down (the VPN still remains active in sleep mode).\nTo deactivate the VPN, you can just restart the device, and it will have resumed regular network connectivity upon reboot. To reactivate the VPN upon reboot, you simply need to enter the KOReader Terminal and type vpn, then press enter.\nCongratulations! Now with the power of self-hosted book servers you can run, the options for your Kobo have dramatically expanded! ü•≥\n","date":"23 April 2025","externalUrl":null,"permalink":"/posts/2025-04-23-kobo-wireguard/","section":"Posts","summary":"Summary # This is a guide to set up userspace Wireguard on the Kobo Clara Colour eReader, allowing you to connect the Kobo to a VPN that uses Wireguard configuration files.","title":"Connecting Kobo to Wireguard VPN","type":"posts"},{"content":"This is a script that lets you paste rich text from other applications such as web browsers or word processors into Emacs Org Mode with formatting included (such as italics, bold, and headings). I have configured the script in a way that it detects the OS and defines the corresponding script accordingly, therefore you can use the same Emacs init file on both Windows and Linux.\nPlease note that for both OS, pandoc needs to be installed and in the PATH. As for Linux, xclip also needs to be installed.\n;; Command for Windows 11 (as of 24H2, which uses Windows PowerShell 5.1), adapted from https://emacs.stackexchange.com/questions/12121/org-mode-parsing-rich-html-directly-when-pasting (when (string-equal system-type \u0026#34;windows-nt\u0026#34;) (defun org-formatted-yank () \u0026#34;Convert clipboard contents from HTML to Org and then paste (yank).\u0026#34; (interactive) ;; Uses PowerShell to get the clipboard text in HTML format ;; Pandoc first simplifies to JSON, before converting to Org Mode format and pastes. ;; --wrap=none is used so the text isn\u0026#39;t artificially wrapped. (kill-new (shell-command-to-string \u0026#34;powershell -command \\\u0026#34;Get-Clipboard -TextFormatType html\\\u0026#34; | pandoc -f html -t json | pandoc -f json -t org --wrap=none\u0026#34;)) (yank))) ;; Command for Linux X11 Systems with xclip installed (tested on Linux Mint 22 Wilma, Cinnamon Edition) (when (string-equal system-type \u0026#34;gnu/linux\u0026#34;) (defun org-formatted-yank () \u0026#34;Convert clipboard contents from HTML to Org and then paste (yank)\u0026#34; ;; (interactive) flags the code as a command that can be executed via M-x (interactive) ;; Creates the clipboard-contents variable and sets it to be an empty string (defvar clipboard-contents \u0026#34;\u0026#34;) ;; Changes the clipboard-contents variable by running a shell command and getting the output of that to the variable. ;; If xclip (which grabs the clipboard contents) doesn\u0026#39;t have the right format available, it outright freezes. Hence \u0026#34;timeout 0.5\u0026#34;. ;; Why this is run: it\u0026#39;s checking the clipboard to see if it has html saved inside. ;; If there is html, clipboard-contents will be filled with the clipboard contents. ;; If there is NO html, clipboard-contents will remain blank. (setq clipboard-contents (shell-command-to-string \u0026#34;timeout 0.5 xclip -o -selection clipboard -t text/html\u0026#34;)) ;; If the variable clipboard-contents is NOT blank (in other words, if the clipboard had html) (if (not (equal \u0026#34;\u0026#34; clipboard-contents)) ;; Execute these two commands: ;; 1. Use pandoc to convert the html in the clipboard first to simplified JSON, then to org mode. Copy the result to the clipboard. --wrap=none is used so the text isn\u0026#39;t artificially wrapped. ;; 2. yank pastes it to the current document ;; NOTE: progn is used because otherwise, only one command can actually be run inside the conditional. (progn (kill-new (shell-command-to-string \u0026#34;xclip -o -selection clipboard -t text/html | pandoc -f html -t json | pandoc -f json -t org --wrap=none\u0026#34;)) (yank) ) ;; If the clipboard-contents IS blank (in other words, if it does not have html), then Emacs will display in the messages pane, \u0026#34;No html in clipboard.\u0026#34; (message \u0026#34;No html in clipboard.\u0026#34;) ))) ;; org-formatted-yank common settings ;; Making sure that Org Mode parses Pandoc\u0026#39;s non-breaking spaces properly ;; This one is for the beginning char (setcar org-emphasis-regexp-components \u0026#34; \\t(\u0026#39;\\\u0026#34;¬†{\u0026#34;) ;; This one is for the ending char. (setcar (nthcdr 1 org-emphasis-regexp-components) \u0026#34;- \\t.,:¬†!?;\u0026#39;\\\u0026#34;)}\\\\\u0026#34;) ;; Setting the shortcut to Ctrl-Shift-y (global-set-key (kbd \u0026#34;C-S-y\u0026#34;) \u0026#39;org-formatted-yank) ","date":"16 January 2025","externalUrl":null,"permalink":"/posts/2025-01-16-org-formatted-yank/","section":"Posts","summary":"This is a script that lets you paste rich text from other applications such as web browsers or word processors into Emacs Org Mode with formatting included (such as italics, bold, and headings).","title":"Org Mode - Pasting with Formatting","type":"posts"},{"content":"This website is the personal portfolio of myself, Matthew Lee, which I use as a way to collect and display my current achievements and skills!\nSince my earliest days, I have always had a fascination with all things digital! My initial career goals were once completely different, but the allure of all the things that computers could do when you were willing to tinker with them with eventually changed my trajectory to the wonderful world of Information Technology!\nThe fields I especially enjoy are programming - especially web applications - as well as system administration. I have enjoyed the latter to the extent that I have made my own improvements to my home network, with its own dedicated Debian server and containers!\nWork Experience # IMI Solutions - Project Support # October 2023 - Ongoing\nPriceline Pharmacy - Pharmacy Assistant # May 2021 - March 2024\nVolunteer Experience # RMIT University - Peer Mentor # July 2022 - December 2023\nCisco Live! - Dream Team # December 2022\nAcademic Portfolio # The Information Technology pathway has taken me through a variety of unique and interesting fields. Typing code, troubleshooting the configuration of malfunctioning network equipment, understanding the theory of what makes a high quality application design, and even an entire real-life business project, I have had a comprehensive experience of many corners of the technology world during my time at RMIT University.\nThe Certificate IV in Information Technology Networking allowed me to gain a foothold of knowledge into technology, and the Associate Degree in Information Technology continued to broaden my horizons. Having completed the Bachelor Degree in Information Technology in 2024 and commenced IT work immediately afterwards, I\u0026rsquo;m looking forward to many more wonderful experiences ahead!\nSkills and Proficiencies Python Programming: IOT, web applications, API development Web Development: HTML, CSS, JavaScript, PHP, SQL Windows Server Administration Linux Server Scripting, Administration, and Containerisation Enterprise Virtualisation: Hyper-V, ESXi, KVM/QEMU Networking and Cybersecurity Java Programming MySQL and DynamoDB Database Management ","externalUrl":null,"permalink":"/about/","section":"Simple Selfhosted Server Guides","summary":"This website is the personal portfolio of myself, Matthew Lee, which I use as a way to collect and display my current achievements and skills!","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"This website has been written in Emacs Org Mode , exported to Hugo format through the ox-hugo package . The Hugo theme I am using is Blowfish .\nMany thanks to Nicholas Lee for inspiration with the About Me section and website design!\nThe credit for website images are as follows:\nSystem (website icon in browser): Ui icons created by Muhammad_Usman - Flaticon Home Page Background Image: Unsplash ","externalUrl":null,"permalink":"/credits/","section":"Simple Selfhosted Server Guides","summary":"This website has been written in Emacs Org Mode , exported to Hugo format through the ox-hugo package .","title":"Website Credits","type":"page"}]